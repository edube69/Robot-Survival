<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robotron: Retro Survival</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #0f0;
            overflow: hidden;
        }
        
        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e, #16213e);
            z-index: 1000;
        }
        
        .title {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: bold;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #00ff41, #0ff, #f0f, #ff0);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
        }
        
        .subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 3rem;
            text-align: center;
            color: #0ff;
            opacity: 0.8;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        
        .start-button {
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Courier New', monospace;
            background: transparent;
            border: 3px solid #0f0;
            color: #0f0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 2rem;
        }
        
        .start-button:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 30px #0f0;
            transform: scale(1.05);
        }
        
        .features {
            text-align: center;
            max-width: 600px;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .feature {
            padding: 1rem;
            border: 1px solid rgba(0, 255, 0, 0.3);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .feature:hover {
            border-color: #0f0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            transform: translateY(-5px);
        }
        
        .feature h3 {
            color: #0ff;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .feature p {
            color: #888;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        /* Game Screen */
        #gameScreen {
            display: none;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #0f0;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        canvas {
            background: #111;
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            font-size: 18px;
            text-shadow: 0 0 10px #0f0;
        }
        
        #gameOver, #reviveScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f00;
            font-size: 24px;
            text-shadow: 0 0 20px #f00;
            display: none;
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border: 2px solid #f00;
            border-radius: 10px;
            max-width: 80%;
        }
        
        #reviveScreen {
            color: #0ff;
            border-color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        
        .revive-option {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .revive-option h4 {
            color: #0ff;
            font-weight: bold;
        }
        
        .revive-option p {
            color: #888;
            font-size: 0.9rem;
        }
        
        .upgrade-benefit {
            color: #ff0;
            font-size: 0.9rem;
        }
        
        #instructions {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #0f0;
            font-size: 14px;
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1 class="title">ROBOTRON</h1>
        <p class="subtitle">Retro Survival Arena</p>
        
        <button class="start-button" onclick="startGame()">
            Start Mission
        </button>
        
        <div class="features">
            <div class="feature-grid">
                <div class="feature">
                    <h3>ðŸ”« Auto-Targeting</h3>
                    <p>Advanced AI targeting system locks onto the nearest threat</p>
                </div>
                <div class="feature">
                    <h3>âš¡ Power Upgrades</h3>
                    <p>Collect gems to unlock devastating abilities and orbital shields</p>
                </div>
                <div class="feature">
                    <h3>ðŸ¤– Enemy Variants</h3>
                    <p>Face off against Fast Scouts, Heavy Tanks, and Splitter Units</p>
                </div>
                <div class="feature">
                    <h3>ðŸ’€ Resurrection</h3>
                    <p>Death is not the end - revive with enhanced abilities</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen">
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="ui">
                <div>SCORE: <span id="score">0</span></div>
                <div>WAVE: <span id="wave">1</span></div>
                <div>LIVES: <span id="lives">3</span></div>
                <div>GEMS: <span id="gems">0</span></div>
                <div>NEXT UPGRADE: <span id="nextUpgrade">75</span></div>
                <div id="movementMode" style="color: #ff0;">MODE: WASD</div>
                <div>RESURRECTIONS: <span id="resurrections">0</span></div>
            </div>
            
            <div id="gameOver">
                <div class="glow">MISSION FAILED</div>
                <div style="font-size: 16px; margin-top: 10px;">Press SPACE to restart or ESC for main menu</div>
            </div>
            
            <div id="reviveScreen">
                <div class="glow">RESURRECTION PROTOCOL</div>
                <div style="font-size: 16px; margin: 20px 0;">Choose your enhanced abilities:</div>
                <div id="reviveOptions"></div>
                <div style="font-size: 14px; margin-top: 20px; color: #888;">
                    Press 1, 2, or 3 to choose â€¢ 4 to skip resurrection
                </div>
            </div>
            
            <div id="instructions">
                WASD: Move | M: Toggle Mouse Mode | S: Toggle Sound | 1,2,3: Choose upgrades | SPACE: Restart
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let gameState = 'menu';
        let canvas, ctx;
        let score = 0, wave = 1, lives = 3, gems = 0, gemsForUpgrade = 75, resurrections = 0;
        let maxResurrections = 3;
        
        // World and camera system
        const world = {
            width: 2400,  // 3x larger world
            height: 1800
        };
        
        const camera = {
            x: 0,
            y: 0,
            followSpeed: 0.1
        };
        
        // Player object with larger size
        const player = {
            x: world.width / 2, 
            y: world.height / 2, 
            radius: 12,  // Increased hitbox
            speed: 4,    // Slightly faster for larger world
            color: '#0ff',
            fireRate: 18, bulletSpeed: 7, bulletSize: 3, bulletLength: 10,
            range: 280, magnetRange: 60, followMouse: false,
            orbCount: 0, orbDamage: 40, invulnerable: false, invulnerableTime: 0,
            vampiric: false, flameMode: false
        };
        
        // Game arrays
        let bullets = [], enemies = [], currencyDrops = [], particles = [], upgradeOptions = [], orbs = [];
        let bulletCooldown = 0, orbTime = 0;
        
        // Input
        const keys = {};
        let mousePos = { x: 400, y: 300 };
        
        // Audio
        let audioContext, soundEnabled = true;
        
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            initGame();
        }

        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update camera first
            updateCamera();

            // Draw world boundaries (optional visual reference)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.strokeRect(-camera.x, -camera.y, world.width, world.height);

            // Draw player robot
            drawPlayer();

            // Draw bullets as lines
            bullets.forEach(bullet => drawBullet(bullet));

            // Draw enemies
            enemies.forEach(enemy => drawEnemy(enemy));

            // Draw currency drops
            currencyDrops.forEach(drop => {
                const screenX = drop.x - camera.x;
                const screenY = drop.y - camera.y;
                const bobY = screenY + Math.sin(drop.bobOffset) * 2;
                
                ctx.fillStyle = drop.color;
                ctx.shadowColor = drop.color;
                ctx.shadowBlur = drop.magnetized ? 15 : 8;
                ctx.beginPath();
                ctx.arc(screenX, bobY, drop.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                if (drop.value > 1) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(drop.value.toString(), screenX, bobY + 3);
                }
            });

            // Draw orbs
            orbs.forEach(orb => {
                const screenX = orb.x - camera.x;
                const screenY = orb.y - camera.y;
                
                ctx.fillStyle = orb.color;
                ctx.shadowColor = orb.color;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(screenX, screenY, orb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                const playerScreenX = player.x - camera.x;
                const playerScreenY = player.y - camera.y;
                ctx.strokeStyle = orb.color + '40';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, orb.distance, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw particles
            particles.forEach(particle => {
                const screenX = particle.x - camera.x;
                const screenY = particle.y - camera.y;
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(screenX, screenY, particle.radius * alpha, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw magnet range
            if (gameState === 'playing') {
                const playerScreenX = player.x - camera.x;
                const playerScreenY = player.y - camera.y;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, player.magnetRange, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw mouse movement indicator
            if (gameState === 'playing' && player.followMouse) {
                const playerScreenX = player.x - camera.x;
                const playerScreenY = player.y - camera.y;
                const dx = mousePos.x - playerScreenX;
                const dy = mousePos.y - playerScreenY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 20) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(playerScreenX, playerScreenY);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 8, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw upgrade screen
            if (gameState === 'upgrade') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0f0';
                ctx.font = '32px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL UP!', canvas.width / 2, 150);

                ctx.font = '18px Courier New';
                for (let i = 0; i < upgradeOptions.length; i++) {
                    const option = upgradeOptions[i];
                    const y = 250 + i * 80;

                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(100, y - 30, canvas.width - 200, 60);

                    ctx.fillStyle = '#0f0';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${i + 1}. ${option.name}`, 120, y - 5);
                    ctx.font = '14px Courier New';
                    ctx.fillStyle = '#888';
                    ctx.fillText(option.desc, 120, y + 15);
                    ctx.font = '18px Courier New';
                    ctx.fillStyle = '#0f0';
                }

                ctx.font = '16px Courier New';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('Press 1, 2, or 3 to choose', canvas.width / 2, canvas.height - 50);
            }
        }
        
        function returnToMenu() {
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            gameState = 'menu';
        }
        
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Initialize audio
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                soundEnabled = false;
            }
            
            // Setup event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            
            restartGame();
            gameLoop();
        }
        
        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ' && gameState === 'gameOver') restartGame();
            if (e.key === 'Escape' && (gameState === 'gameOver' || gameState === 'playing')) returnToMenu();
            if (e.key.toLowerCase() === 'm' && gameState === 'playing') player.followMouse = !player.followMouse;
            if (e.key.toLowerCase() === 's') soundEnabled = !soundEnabled;
            
            if (gameState === 'upgrade') {
                if (e.key === '1') selectUpgrade(0);
                if (e.key === '2') selectUpgrade(1);
                if (e.key === '3') selectUpgrade(2);
            }
            
            if (gameState === 'revive') {
                if (e.key === '1') selectReviveUpgrade(0);
                if (e.key === '2') selectReviveUpgrade(1);
                if (e.key === '3') selectReviveUpgrade(2);
                if (e.key === '4') skipResurrection();
            }
        }
        
        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        }
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playSoundEffect(type) {
            switch(type) {
                case 'shoot': playSound(800, 0.1, 'square', 0.05); break;
                case 'enemyHit': playSound(300, 0.2, 'sawtooth', 0.08); break;
                case 'playerHit': playSound(150, 0.5, 'triangle', 0.15); break;
                case 'gemCollect': 
                    playSound(600, 0.15, 'sine', 0.06);
                    setTimeout(() => playSound(800, 0.1, 'sine', 0.04), 50);
                    break;
                case 'upgrade':
                    playSound(400, 0.2, 'sine', 0.1);
                    setTimeout(() => playSound(600, 0.2, 'sine', 0.1), 100);
                    setTimeout(() => playSound(800, 0.2, 'sine', 0.1), 200);
                    break;
                case 'revive':
                    playSound(200, 0.3, 'sine', 0.1);
                    setTimeout(() => playSound(400, 0.3, 'sine', 0.1), 150);
                    setTimeout(() => playSound(600, 0.3, 'sine', 0.1), 300);
                    break;
            }
        }
        
        function findNearestEnemy() {
            if (enemies.length === 0) return null;
            
            let nearest = enemies[0];
            let nearestDistance = Math.sqrt((player.x - nearest.x) ** 2 + (player.y - nearest.y) ** 2);
            
            for (let i = 1; i < enemies.length; i++) {
                const enemy = enemies[i];
                const distance = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                if (distance < nearestDistance) {
                    nearest = enemy;
                    nearestDistance = distance;
                }
            }
            
            return { enemy: nearest, distance: nearestDistance };
        }
        
        function createBullet(targetEnemy = null) {
            let dx, dy;
            
            if (targetEnemy) {
                dx = targetEnemy.x - player.x;
                dy = targetEnemy.y - player.y;
            } else {
                dx = mousePos.x - player.x;
                dy = mousePos.y - player.y;
            }
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: (dx / distance) * player.bulletSpeed,
                    vy: (dy / distance) * player.bulletSpeed,
                    radius: player.bulletSize,
                    length: player.bulletLength,
                    color: '#ff0'
                });
                playSoundEffect('shoot');
            }
        }
        
        function updateCamera() {
            // Calculate target camera position (center player on screen)
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;
            
            // Smooth camera following
            camera.x += (targetX - camera.x) * camera.followSpeed;
            camera.y += (targetY - camera.y) * camera.followSpeed;
            
            // Keep camera within world bounds
            camera.x = Math.max(0, Math.min(world.width - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(world.height - canvas.height, camera.y));
        }
        
        function createEnemy() {
            // Spawn enemies around the player in the larger world
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            // Spawn relative to player position with larger spawn distances
            const spawnDistance = 400;
            
            switch(side) {
                case 0: // top
                    x = player.x + (Math.random() - 0.5) * spawnDistance * 2;
                    y = player.y - spawnDistance;
                    break;
                case 1: // right
                    x = player.x + spawnDistance;
                    y = player.y + (Math.random() - 0.5) * spawnDistance * 2;
                    break;
                case 2: // bottom
                    x = player.x + (Math.random() - 0.5) * spawnDistance * 2;
                    y = player.y + spawnDistance;
                    break;
                case 3: // left
                    x = player.x - spawnDistance;
                    y = player.y + (Math.random() - 0.5) * spawnDistance * 2;
                    break;
            }
            
            // Keep spawns within world bounds
            x = Math.max(20, Math.min(world.width - 20, x));
            y = Math.max(20, Math.min(world.height - 20, y));
            
            const rand = Math.random();
            let enemyType = 'basic';
            
            // More varied distribution for larger hordes
            if (wave >= 2) {
                if (rand < 0.5) enemyType = 'basic';      // 50% basic
                else if (rand < 0.75) enemyType = 'fast';  // 25% fast
                else if (rand < 0.9) enemyType = 'tank';   // 15% tank
                else enemyType = 'splitter';               // 10% splitter
            }
            
            const enemyData = {
                basic: { 
                    radius: 6, 
                    speed: 1.5 + Math.random() * 1.5,
                    color: '#f0f', 
                    health: 1, 
                    points: 100, 
                    shape: 'triangle' 
                },
                fast: { 
                    radius: 4, 
                    speed: 3.5 + Math.random() * 1.5, 
                    color: '#f44', 
                    health: 1, 
                    points: 150, 
                    shape: 'diamond' 
                },
                tank: { 
                    radius: 11, 
                    speed: 1 + Math.random() * 0.8,
                    color: '#84f', 
                    health: 4, 
                    points: 400, 
                    shape: 'hexagon' 
                },
                splitter: { 
                    radius: 8, 
                    speed: 1.5 + Math.random() * 1, 
                    color: '#f80', 
                    health: 3, 
                    points: 350, 
                    shape: 'star' 
                }
            };
            
            const enemy = { x, y, ...enemyData[enemyType], type: enemyType, maxHealth: enemyData[enemyType].health };
            enemies.push(enemy);
        }
        
        function createCurrencyDrop(x, y) {
            const value = Math.random() < 0.2 ? 3 : 1;
            currencyDrops.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                radius: value === 3 ? 5 : 3,
                value: value,
                color: value === 3 ? '#0f0' : '#4f4',
                magnetized: false,
                bobOffset: Math.random() * Math.PI * 2
            });
        }
        
        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    radius: Math.random() * 3 + 1,
                    color: color,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function generateUpgradeOptions() {
            const upgrades = [
                { name: "Fire Rate+", desc: "Shoot faster", apply: () => player.fireRate = Math.max(6, player.fireRate - 3) },
                { name: "Speed+", desc: "Move faster", apply: () => player.speed += 0.8 },
                { name: "Bullet Speed+", desc: "Bullets fly faster", apply: () => player.bulletSpeed += 1.5 },
                { name: "Range+", desc: "Shoot further", apply: () => player.range += 40 },
                { name: "Health+", desc: "Gain extra life", apply: () => lives++ },
                { name: "Orbital Shield", desc: "Add protective orb", apply: () => { player.orbCount++; createOrb(); } }
            ];
            
            upgradeOptions = [];
            for (let i = 0; i < 3; i++) {
                const index = Math.floor(Math.random() * upgrades.length);
                upgradeOptions.push(upgrades.splice(index, 1)[0]);
            }
        }
        
        function generateReviveOptions() {
            const reviveUpgrades = [
                { 
                    name: "Phoenix Protocol", 
                    desc: "Double fire rate + flame bullets",
                    benefit: "+100% fire rate, flame damage",
                    apply: () => {
                        player.fireRate = Math.max(3, Math.floor(player.fireRate * 0.5));
                        player.bulletSpeed += 3;
                    }
                },
                { 
                    name: "Ghost Mode", 
                    desc: "Temporary invincibility + speed boost",
                    benefit: "10 seconds invulnerable, +50% speed",
                    apply: () => {
                        player.speed += 2;
                        player.invulnerable = true;
                        player.invulnerableTime = 600;
                    }
                },
                { 
                    name: "Berserker Rage", 
                    desc: "Triple orbs + massive damage",
                    benefit: "+3 orbital shields, +50% damage",
                    apply: () => {
                        for(let i = 0; i < 3; i++) {
                            player.orbCount++;
                            createOrb();
                        }
                        player.orbDamage += 30;
                    }
                }
            ];
            
            upgradeOptions = [];
            for (let i = 0; i < 3; i++) {
                const index = Math.floor(Math.random() * reviveUpgrades.length);
                upgradeOptions.push(reviveUpgrades.splice(index, 1)[0]);
            }
        }
        
        function selectUpgrade(index) {
            if (upgradeOptions[index]) {
                upgradeOptions[index].apply();
                gems -= gemsForUpgrade;
                gemsForUpgrade = Math.floor(gemsForUpgrade * 1.5);
                gameState = 'playing';
                upgradeOptions = [];
            }
        }
        
        function selectReviveUpgrade(index) {
            if (upgradeOptions[index]) {
                upgradeOptions[index].apply();
                resurrections++;
                gameState = 'playing';
                upgradeOptions = [];
                playSoundEffect('revive');
                document.getElementById('reviveScreen').style.display = 'none';
                
                player.x = world.width / 2;
                player.y = world.height / 2;
                
                // Clear nearby enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const dist = Math.sqrt((enemies[j].x - player.x) ** 2 + (enemies[j].y - player.y) ** 2);
                    if (dist < 150) enemies.splice(j, 1);
                }
                
                createParticles(player.x, player.y, '#0ff', 20);
            }
        }
        
        function skipResurrection() {
            gameState = 'gameOver';
            document.getElementById('reviveScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function createOrb() {
            orbs.push({
                angle: (orbs.length * (Math.PI * 2)) / Math.max(player.orbCount, 1),
                radius: 5,
                distance: 40,
                color: '#ff8800',
                damage: player.orbDamage
            });
        }
        
        function updatePlayer() {
            if (gameState !== 'playing') return;
            
            if (player.invulnerable && player.invulnerableTime > 0) {
                player.invulnerableTime--;
                if (player.invulnerableTime <= 0) player.invulnerable = false;
            }
            
            let moveX = 0, moveY = 0;
            
            if (player.followMouse) {
                // Convert mouse position to world coordinates
                const worldMouseX = mousePos.x + camera.x;
                const worldMouseY = mousePos.y + camera.y;
                
                const dx = worldMouseX - player.x;
                const dy = worldMouseY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    const normalizedSpeed = Math.min(distance / 100, 1);
                    moveX = (dx / distance) * player.speed * normalizedSpeed;
                    moveY = (dy / distance) * player.speed * normalizedSpeed;
                }
            } else {
                if (keys['w'] || keys['arrowup']) moveY -= player.speed;
                if (keys['s'] || keys['arrowdown']) moveY += player.speed;
                if (keys['a'] || keys['arrowleft']) moveX -= player.speed;
                if (keys['d'] || keys['arrowright']) moveX += player.speed;
                
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.707;
                    moveY *= 0.707;
                }
            }
            
            player.x += moveX;
            player.y += moveY;
            
            // Keep player within world bounds
            player.x = Math.max(player.radius, Math.min(world.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(world.height - player.radius, player.y));
            
            if (bulletCooldown <= 0) {
                const nearestResult = findNearestEnemy();
                if (nearestResult && nearestResult.distance < player.range) {
                    createBullet(nearestResult.enemy);
                    bulletCooldown = player.fireRate;
                }
            }
            if (bulletCooldown > 0) bulletCooldown--;
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Remove bullets that go outside world bounds
                if (bullet.x < 0 || bullet.x > world.width || bullet.y < 0 || bullet.y > world.height) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updateEnemies() {
            if (gameState !== 'playing') return;
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                const playerDistance = Math.sqrt((enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2);
                
                if (playerDistance < enemy.radius + player.radius && !player.invulnerable) {
                    createParticles(player.x, player.y, '#f00', 12);
                    lives--;
                    playSoundEffect('playerHit');
                    
                    if (lives <= 0) {
                        if (resurrections < maxResurrections) {
                            gameState = 'revive';
                            generateReviveOptions();
                            showReviveScreen();
                        } else {
                            gameState = 'gameOver';
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    } else {
                        player.x = world.width / 2;
                        player.y = world.height / 2;
                        // Clear nearby enemies
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const dist = Math.sqrt((enemies[j].x - player.x) ** 2 + (enemies[j].y - player.y) ** 2);
                            if (dist < 100) enemies.splice(j, 1);
                        }
                    }
                }
                
                // Bullet collision
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    const bulletDistance = Math.sqrt((bullet.x - enemy.x) ** 2 + (bullet.y - enemy.y) ** 2);
                    
                    if (bulletDistance < bullet.radius + enemy.radius) {
                        enemy.health--;
                        bullets.splice(j, 1);
                        
                        if (enemy.health <= 0) {
                            createParticles(enemy.x, enemy.y, enemy.color, 8);
                            createCurrencyDrop(enemy.x, enemy.y);
                            playSoundEffect('enemyHit');
                            
                            if (player.vampiric && lives < 10) lives++;
                            
                            enemies.splice(i, 1);
                            score += enemy.points;
                        } else {
                            createParticles(enemy.x, enemy.y, enemy.color, 3);
                        }
                        break;
                    }
                }
            }
        }
        
        function showReviveScreen() {
            document.getElementById('reviveScreen').style.display = 'block';
            const optionsDiv = document.getElementById('reviveOptions');
            optionsDiv.innerHTML = '';
            for (let j = 0; j < upgradeOptions.length; j++) {
                const option = upgradeOptions[j];
                optionsDiv.innerHTML += `
                    <div class="revive-option">
                        <h4>${j + 1}. ${option.name}</h4>
                        <p>${option.desc}</p>
                        <div class="upgrade-benefit">${option.benefit}</div>
                    </div>
                `;
            }
        }
        
        function updateCurrencyDrops() {
            for (let i = currencyDrops.length - 1; i >= 0; i--) {
                const drop = currencyDrops[i];
                
                const dx = player.x - drop.x;
                const dy = player.y - drop.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.magnetRange && !drop.magnetized) {
                    drop.magnetized = true;
                }
                
                if (drop.magnetized) {
                    const speed = 6;
                    drop.vx = (dx / distance) * speed;
                    drop.vy = (dy / distance) * speed;
                } else {
                    drop.vx *= 0.95;
                    drop.vy *= 0.95;
                }
                
                drop.x += drop.vx;
                drop.y += drop.vy;
                
                if (distance < drop.radius + player.radius) {
                    gems += drop.value;
                    createParticles(drop.x, drop.y, drop.color, 4);
                    currencyDrops.splice(i, 1);
                    playSoundEffect('gemCollect');
                    
                    if (gems >= gemsForUpgrade) {
                        gameState = 'upgrade';
                        generateUpgradeOptions();
                        playSoundEffect('upgrade');
                    }
                }
                
                drop.bobOffset += 0.1;
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function updateOrbs() {
            orbTime += 0.05;
            
            for (let i = 0; i < orbs.length; i++) {
                const orb = orbs[i];
                orb.angle = (i * (Math.PI * 2)) / Math.max(orbs.length, 1) + orbTime;
                
                orb.x = player.x + Math.cos(orb.angle) * orb.distance;
                orb.y = player.y + Math.sin(orb.angle) * orb.distance;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distance = Math.sqrt((orb.x - enemy.x) ** 2 + (orb.y - enemy.y) ** 2);
                    
                    if (distance < orb.radius + enemy.radius) {
                        enemy.health--;
                        
                        if (enemy.health <= 0) {
                            createParticles(enemy.x, enemy.y, orb.color, 8);
                            createCurrencyDrop(enemy.x, enemy.y);
                            
                            if (player.vampiric && lives < 10) lives++;
                            
                            enemies.splice(j, 1);
                            score += orb.damage;
                        } else {
                            createParticles(enemy.x, enemy.y, orb.color, 4);
                        }
                        break;
                    }
                }
            }
        }
        
        function spawnEnemies() {
            if (gameState !== 'playing') return;
            
            // Much more aggressive spawning for hordes
            const enemiesNeeded = Math.min(8 + wave * 2, 35); // Increased from 4 + wave to 8 + wave*2, max 35
            const spawnRate = 0.08 + wave * 0.02; // Increased spawn rate significantly
            
            if (enemies.length < enemiesNeeded && Math.random() < spawnRate) {
                createEnemy();
                
                // Chance for multiple spawns at once (horde effect)
                if (wave > 2 && Math.random() < 0.3) {
                    setTimeout(() => createEnemy(), 100);
                }
                if (wave > 4 && Math.random() < 0.2) {
                    setTimeout(() => createEnemy(), 200);
                }
                if (wave > 6 && Math.random() < 0.1) {
                    setTimeout(() => createEnemy(), 300);
                }
            }
            
            if (enemies.length === 0) {
                wave++;
                // Spawn larger initial waves
                const initialSpawn = Math.min(5 + wave * 2, 15);
                for (let i = 0; i < initialSpawn; i++) {
                    setTimeout(() => createEnemy(), i * 200); // Faster initial spawning
                }
            }
        }
        
        function drawBullet(bullet) {
            // Convert to screen coordinates
            const screenX = bullet.x - camera.x;
            const screenY = bullet.y - camera.y;
            
            // Only draw if on screen
            if (screenX < -20 || screenX > canvas.width + 20 || 
                screenY < -20 || screenY > canvas.height + 20) return;
            
            ctx.strokeStyle = bullet.color;
            ctx.shadowColor = bullet.color;
            ctx.shadowBlur = 8;
            ctx.lineWidth = bullet.radius;
            ctx.lineCap = 'round';
            
            const angle = Math.atan2(bullet.vy, bullet.vx);
            const length = bullet.length;
            
            const startX = screenX - Math.cos(angle) * length / 2;
            const startY = screenY - Math.sin(angle) * length / 2;
            const endX = screenX + Math.cos(angle) * length / 2;
            const endY = screenY + Math.sin(angle) * length / 2;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        function drawEnemy(enemy) {
            // Convert to screen coordinates
            const screenX = enemy.x - camera.x;
            const screenY = enemy.y - camera.y;
            
            // Only draw if on screen (with some margin)
            if (screenX < -50 || screenX > canvas.width + 50 || 
                screenY < -50 || screenY > canvas.height + 50) return;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 12;
            ctx.fillStyle = enemy.color;
            
            ctx.beginPath();
            switch(enemy.shape) {
                case 'triangle':
                    ctx.moveTo(0, -enemy.radius);
                    ctx.lineTo(-enemy.radius * 0.8, enemy.radius * 0.6);
                    ctx.lineTo(enemy.radius * 0.8, enemy.radius * 0.6);
                    ctx.closePath();
                    break;
                    
                case 'diamond':
                    ctx.moveTo(0, -enemy.radius);
                    ctx.lineTo(enemy.radius, 0);
                    ctx.lineTo(0, enemy.radius);
                    ctx.lineTo(-enemy.radius, 0);
                    ctx.closePath();
                    break;
                    
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const x = Math.cos(angle) * enemy.radius;
                        const y = Math.sin(angle) * enemy.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star':
                    const spikes = 5;
                    for (let i = 0; i < spikes * 2; i++) {
                        const angle = (i * Math.PI) / spikes;
                        const radius = i % 2 === 0 ? enemy.radius : enemy.radius * 0.5;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                    
                default:
                    ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            }
            
            ctx.fill();
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Health bar for multi-HP enemies
            if (enemy.maxHealth > 1) {
                const barWidth = enemy.radius * 2;
                const barHeight = 3;
                const barY = screenY - enemy.radius - 10;
                
                ctx.fillStyle = '#444';
                ctx.fillRect(screenX - barWidth/2, barY, barWidth, barHeight);
                
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : '#f80';
                ctx.fillRect(screenX - barWidth/2, barY, barWidth * healthPercent, barHeight);
            }
        }
        
        function drawPlayer() {
            ctx.save();
            
            // Translate to screen position (camera-relative)
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            ctx.translate(screenX, screenY);
            
            // Apply invulnerability effect
            if (player.invulnerable) {
                const flash = Math.sin(Date.now() * 0.02) > 0;
                if (flash) {
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 25;
                } else {
                    ctx.shadowColor = player.color;
                    ctx.shadowBlur = 15;
                }
            } else {
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 15;
            }
            
            const robotColor = player.invulnerable && Math.sin(Date.now() * 0.02) > 0 ? '#fff' : '#0ff';
            const bodyColor = player.invulnerable && Math.sin(Date.now() * 0.02) > 0 ? '#fff' : '#0dd';
            const detailColor = player.invulnerable && Math.sin(Date.now() * 0.02) > 0 ? '#fff' : '#0aa';
            
            // Draw robot body (larger main rectangle)
            ctx.fillStyle = robotColor;
            ctx.fillRect(-8, -10, 16, 20);
            
            // Draw robot head (larger top section)
            ctx.fillStyle = bodyColor;
            ctx.fillRect(-6, -14, 12, 6);
            
            // Draw robot eyes (larger yellow rectangles)
            ctx.fillStyle = '#ff0';
            ctx.fillRect(-4, -12, 2, 2);  // Left eye
            ctx.fillRect(2, -12, 2, 2);   // Right eye
            
            // Draw robot shoulder weapons (Robotron style)
            ctx.fillStyle = detailColor;
            ctx.fillRect(-12, -8, 4, 6);   // Left shoulder weapon
            ctx.fillRect(8, -8, 4, 6);     // Right shoulder weapon
            
            // Draw robot arms (extending from shoulders)
            ctx.fillStyle = detailColor;
            ctx.fillRect(-10, -2, 3, 8);   // Left arm
            ctx.fillRect(7, -2, 3, 8);     // Right arm
            
            // Draw robot legs (larger base)
            ctx.fillStyle = '#088';
            ctx.fillRect(-6, 6, 4, 8);     // Left leg
            ctx.fillRect(2, 6, 4, 8);      // Right leg
            
            // Draw weapon barrels on shoulders
            ctx.fillStyle = '#666';
            ctx.fillRect(-11, -7, 2, 2);   // Left barrel
            ctx.fillRect(9, -7, 2, 2);     // Right barrel
            
            // Draw muzzle flash when shooting (larger effect)
            if (bulletCooldown > player.fireRate - 4) {
                ctx.fillStyle = '#ff0';
                ctx.fillRect(-15, -7, 4, 2);   // Left muzzle flash
                ctx.fillRect(11, -7, 4, 2);    // Right muzzle flash
                
                // Add spark effects
                ctx.fillStyle = '#fff';
                ctx.fillRect(-16, -6, 1, 1);
                ctx.fillRect(15, -6, 1, 1);
            }
            
            // Draw chest panel details
            ctx.fillStyle = '#044';
            ctx.fillRect(-3, -6, 6, 4);    // Chest panel
            ctx.fillStyle = '#0ff';
            ctx.fillRect(-2, -5, 1, 1);    // Control light 1
            ctx.fillRect(0, -5, 1, 1);     // Control light 2
            ctx.fillRect(1, -5, 1, 1);     // Control light 3
            
            // Draw antenna on head (classic Robotron detail)
            ctx.fillStyle = robotColor;
            ctx.fillRect(-1, -16, 2, 2);
            ctx.fillRect(0, -18, 1, 2);
            
            ctx.restore();
            ctx.shadowBlur = 0;
        }
        
        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw player robot
            drawPlayer();
            
            // Draw bullets as lines
            bullets.forEach(bullet => drawBullet(bullet));
            
            // Draw enemies
            enemies.forEach(enemy => drawEnemy(enemy));
            
            // Draw currency drops
            currencyDrops.forEach(drop => {
                const bobY = drop.y + Math.sin(drop.bobOffset) * 2;
                ctx.fillStyle = drop.color;
                ctx.shadowColor = drop.color;
                ctx.shadowBlur = drop.magnetized ? 15 : 8;
                ctx.beginPath();
                ctx.arc(drop.x, bobY, drop.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                if (drop.value > 1) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(drop.value.toString(), drop.x, bobY + 3);
                }
            });
            
            // Draw orbs
            orbs.forEach(orb => {
                ctx.fillStyle = orb.color;
                ctx.shadowColor = orb.color;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = orb.color + '40';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(player.x, player.y, orb.distance, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Draw particles
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius * alpha, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw magnet range
            if (gameState === 'playing') {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.magnetRange, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw mouse movement indicator
            if (gameState === 'playing' && player.followMouse) {
                const dx = mousePos.x - player.x;
                const dy = mousePos.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw upgrade screen
            if (gameState === 'upgrade') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0f0';
                ctx.font = '32px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL UP!', canvas.width / 2, 150);
                
                ctx.font = '18px Courier New';
                for (let i = 0; i < upgradeOptions.length; i++) {
                    const option = upgradeOptions[i];
                    const y = 250 + i * 80;
                    
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(100, y - 30, canvas.width - 200, 60);
                    
                    ctx.fillStyle = '#0f0';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${i + 1}. ${option.name}`, 120, y - 5);
                    ctx.font = '14px Courier New';
                    ctx.fillStyle = '#888';
                    ctx.fillText(option.desc, 120, y + 15);
                    ctx.font = '18px Courier New';
                    ctx.fillStyle = '#0f0';
                }
                
                ctx.font = '16px Courier New';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('Press 1, 2, or 3 to choose', canvas.width / 2, canvas.height - 50);
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('lives').textContent = lives;
            document.getElementById('gems').textContent = gems;
            document.getElementById('nextUpgrade').textContent = Math.max(0, gemsForUpgrade - gems);
            document.getElementById('resurrections').textContent = resurrections;
            document.getElementById('movementMode').textContent = 
                player.followMouse ? 'MODE: MOUSE' : 'MODE: WASD';
        }
        
        function restartGame() {
            gameState = 'playing';
            score = 0;
            wave = 1;
            lives = 3;
            gems = 0;
            gemsForUpgrade = 75;
            resurrections = 0;
            
            // Reset player
            player.x = world.width / 2;
            player.y = world.height / 2;
            player.speed = 3;
            player.fireRate = 18;
            player.bulletSpeed = 6;
            player.bulletSize = 3;
            player.bulletLength = 8;
            player.range = 250;
            player.magnetRange = 50;
            player.followMouse = false;
            player.orbCount = 0;
            player.orbDamage = 40;
            player.invulnerable = false;
            player.invulnerableTime = 0;
            player.vampiric = false;
            
            // Clear arrays
            bullets = [];
            enemies = [];
            particles = [];
            currencyDrops = [];
            upgradeOptions = [];
            orbs = [];
            bulletCooldown = 0;
            orbTime = 0;
            
            // Hide screens
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('reviveScreen').style.display = 'none';
            
            // Spawn initial horde
            for (let i = 0; i < 6; i++) { // Start with more enemies
                setTimeout(() => createEnemy(), i * 200);
            }
        }
        
        function gameLoop() {
            if (gameState === 'playing') {
                updatePlayer();
                updateBullets();
                updateEnemies();
                updateCurrencyDrops();
                updateParticles();
                updateOrbs();
                spawnEnemies();
            }
            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>